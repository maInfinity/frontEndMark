# 1.HTTP状态码

## ①1xx：信息性状态码

**101：切换请求协议**

## ②2xx：成功

**200：请求成功**

## ③3xx：重定向

**301：永久重定向，如域名永久的变更，会缓存**

**302：临时重定向，如未登录跳转到登录；页面404跳转到首页，不缓存**

## ④4xx：客户端错误

400：客户端请求语法错误

403：禁止访问（forbidden），权限相关

404：页面Not Found，服务器无法根据客户端的请求找到资源

## ⑤5xx：服务器错误

500：服务端错误

# 2.常见端口

80：HTTP

443：HTTPS

21：FTP

25：SMTP

# 3.计算机网络体系结构

## ①OSI七层模型协议：

<1>应用层，表示层，会话层

<2>传输层，网络层

<3>数据链路层，物理层

## ②TCP/IP 4层体系结构

<1>应用层：**HTTP， HTTPS， DNS(UDP对应）， FTP， SMTP**

<2>传输层：**TCP， UDP**

<3>网际层：**IP， ICMP， IGMP**

<4>网络接口层

## ③TCP/IP 5层网络体系结构

<1>应用层：**为用户的应用程序提供网络服务的接口**。**将用户的操作通过应用程序转换成为服务，并匹配一个相应的服务协议发送给传输层**。

<2>**传输层：为应用进程之间提供端到端的逻辑通信**

(1)对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能

(2)包含的协议：**TCP， UDP**

(3)重要设备：**网关**

<3>**网络层：路由选择，路由及逻辑寻址**

(1)对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能

(2)包含的协议：**IP， ICMP， IGMP，ARP，RARP**

(3)重要设备：**路由器**

**Tips——传输层和网络层的区别：**

**网络层**只是**根据网络地址将源结点发出的数据包传送到目的结点**，而**传输层**则**负责将数据可靠地传送到相应的端口**。

<4>**数据链路层：**

(1)数据链路层**为网络层提供可靠的数据传输**

(2)主要的协议是**以太网协议**

(3)两个重要的设备：**网桥和交换机**

<5>物理层

# 4.HTTP无状态

当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。简言之，服务器不会去记住你是谁，所以是无状态协议

**加cookie能记住状态了**

# 5.从输入URL到页面显示

①DNS解析，查找域名对应IP地址

②三次握手建立TCP连接

③向服务器发送HTTP请求

④服务器处理请求，返回网页内容

⑤浏览器解析，渲染页面

⑥四次挥手断开连接

# 6.HTTP 1.0，1.1，2.0区别

## ①HTTP1.0

默认短连接，每次请求都要建立一个TCP连接，可以设置`connection: keep-alive`**强制开启长连接**

## ②HTTP1.1

<1>**默认长连接**，即TCP连接默认不关闭。可以被多个请求复用。

<2>分块传输编码，即服务端每产生一块数据，就发送一块，用”流模式”取代”缓存模式”。

<3>管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。

## ③HTTP2.0

<1>1.1版本的**头信息是文本**，**数据体是文本或二进制**。2.0版本**都是二进制**

<2>报头压缩：HTTP不带状态，所以每次请求都要附带所有信息。HTTP2.0引入头信息压缩机制，使用gzip或compress压缩后再发送

<3>服务端推送：允许服务器端未经请求向客户端发送资源

<4>完全多路复用：在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。

多路复用

# 7.GET和POST区别

①数据包：GET产生一个TCP数据包。 POST产生两个

②编码方式：GET只能URL编码。 POST有多种编码方式

③请求参数：GET在URL中，通过&连接。POST在请求体中，通过request body传送

④请求缓存：GET会被主动缓存。 POST不会缓存，除非手动设置

⑤历史记录：GET参数会被完整保存在浏览历史记录里。POST不会保存

⑥参数数据类型：GET是ASCII字符。POST无限制

# 8.HTTP和HTTPS的区别

①端口：HTTP是80， HTTPS是443

②安全性：HTTP不安全， HTTPS安全

③资源消耗：HTTP低，HTTPS高

④报文是否加密：HTTP明文传输，HTTPS密文

⑤是否需要证书：HTTP不需要，HTTPS需要

HTTPS = HTTP + SSL/TLS，也就是用SSL/TLS对数据进行加密和解密，Http进行传输。

# 9.HTTPS流程

①客户端发起HTTPS请求

②服务端将自己的数字证书发送给客户端（公钥就在这个证书里，私钥由服务器持有）

③客户端验证数字证书是否通过：<1>不通过会警告证书存在问题<2>通过则会随机生成一个对称密钥，用公钥加密

④客户端将用公钥加密后的密钥发送给服务端

⑤服务端用私钥非对称解密，得到客户端的密钥，然后用客户端密钥对数据对称加密，发送给客户端

⑥客户端用密钥解密，得到数据

# 10.HTTP流程

①客户端进行DNS域名解析，获得对应的IP地址

②根据IP地址找到服务器，三次握手建立TCP连接

③发送HTTP请求

④服务器响应请求，返回客户端html代码

⑤浏览器解析响应的数据，并渲染

⑥四次挥手断开连接

# 11.数字签名和数字证书

数字证书：公钥，个人信息，数字签名  共同构成数字证书

数字签名：将公钥，个人信息经过Hash摘要算法加密形成消息摘要，再通过CA用私钥加密形成数字签名

# 12.DNS解析过程

DNS解析查找过程假设你要查询**`www.baidu.com`**的IP地址:

①首先会**查找浏览器的缓存**,看看是否能找到**`www.baidu.com`**对应的IP地址，找到就直接返回；否则进行下一步

②将请求**发给本地DNS服务器**，如果查找到也直接返回，否则继续进行下一步

③本地DNS服务器**向根域名服务器发送请求**，根域名服务器**返回负责.com的顶级域名服务器的IP地址的列表**

④本地DNS服务器再**向其中一个负责.com的顶级域名服务器发送一个请求**，**返回负责.baidu的权威域名服务器的IP地址列表**

⑤本地DNS服务器再**向其中一个权威域名服务器发送一个请求**，返回**`www.baidu.com`**所对应的IP地址。”

# 13.三次握手

## ①过程

<1>第一次握手，客户端发送（SYN=1， seq = x）后，客户端处于SYN_SEND状态

<2>第二次握手，服务端发送（SYN=1，ACK = 1，seq = y，ack = x + 1）后，服务端处于SYN_RCV状态

<3>第三次握手，客户端发送（ACK = 1，seq = x + 1，ack = y + 1）后，客户端处于established状态，服务端接收到包后，也变成established状态

**注意：**只有第三次握手可以携带数据

## ②为什么不能2次，4次

2次的话：服务端不知道客户端是否收到了

4次的话：多余

# 14.四次挥手

## ①过程

<1>第一次挥手，客户端发送（FIN = 1，seq = u）后，客户端处于FIN_WAIT-1状态

<2>第二次挥手，服务端发送（ACK = 1，seq = v，ack = u + 1）后，服务端处于CLOSE_WAIT状态，客户端收到确认包后，进入FIN_WAIT-2状态

<3>第三次挥手，服务端发送（FIN = 1，ACK = 1， seq = w，ack = u + 1）后，服务端处于LAST_ACK状态

<4>第四次挥手，客户端发送（ACK = 1，seq = u + 1， ack = w + 1）后，客户端处于TIME-WAIT状态。等待某个固定时间即2MSL（2个最大段生命周期）后，没有收到服务端的ACK，则认为服务端正常关闭连接，则客户端也关闭，进入CLOSED状态；服务端收到第四次挥手客户端发来的确认包后，关闭连接，进入CLOSED状态

## ②为什么需要4次

<1>客户端要求断开连接（第1次），服务端确认断开（第2次），但此时服务端可能还有要发送的数据

<2>服务端发送完了，再发送请求要求断开连接（第3次），客户端确认断开（第4次），彻底关闭连接

## ③为什么要等2MSL

<1>**为了保证客户端发送的最后一个ACK报文段能够到达服务端：**这个ACK报文段有可能丢失，因而使处在**LAST-ACK**状态的服务端就收不到对已发送的**FIN + ACK**报文段的确认。服务端会超时重传这个FIN+ACK 报文段，而客户端就能在 2MSL 时间内（**超时 + 1MSL 传输**）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动2MSL计时器。最后，客户端和服务器都正常进入到**CLOSED**状态。

<2>**防止已失效的连接请求报文段出现在本连接中：**客户端在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

# 15.TCP滑动窗口

## ①发送端的滑动窗口

<1>已发送且已收到ACK确认

<2>已发送但未收到ACK确认

<3>未发送但可以发送

<4>未发送也不能发送

SND.WND：表示发送窗口的大小

SND.NXT：下一个发送的位置，它指向**未发送但可以发送**的第一个字节的序列号

SND.UNA: 一个绝对指针，它指向的是**已发送但未确认**的第一个字节的序列号。

## ②接收端的滑动窗口

<1>已成功接收并确认

<2>未收到数据但可以接收

<3>未收到数据并且不可以接收

REV.WND：表示接收窗口的大小

REV.NXT：下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。

# 16.TCP拥塞控制

拥塞控制是**作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况**。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟**流量控制**又有什么区别呢？流量控制是作用于接收者的，根据**接收端的实际接收能力控制发送速度**，防止分组丢失的。

①慢启动算法

<1>TCP连接完成，初始化cwnd = 1，表明可以传一个MSS单位大小的数据

<2>每当收到一个ACK，cwnd就加一

<3>每当过了一个RTT（轮次），cwnd就增加一倍; 呈指数让升

为了防止cwnd增长过大引起网络拥塞，还需设置一个**慢启动阀值ssthresh**（slow start threshold）状态变量。当cwnd到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当**cwnd >ssthresh**时，进入了**拥塞避免**算法。

②拥塞避免算法

一般来说，慢启动阀值ssthresh是65535字节，cwnd到达**慢启动阀值**后

<1>每收到一个ACK时，cwnd = cwnd + 1/cwnd

<2>每过一个RTT时，cwnd = cwnd + 1

③拥塞发生

当网络拥塞发生**丢包**时，会有两种情况：**RTO超时重传** 和 **快速重传**

<1>发生了**RTO超时重传**，就会使用拥塞发生算法：（这种很不好，不如快速重传）

(1)慢启动阀值sshthresh = cwnd /2

(2)cwnd 重置为 1

(3)进入新的慢启动过程

<2>快速重传：发送方收到3个连续重复的ACK时，就会快速地重传，不必等待**RTO超时**再重传。

(1)拥塞窗口大小 cwnd = cwnd/2

(2)慢启动阀值 ssthresh = cwnd

(3)进入快速恢复算法

④快速恢复

cwnd = sshthresh + 3

重传重复的那几个ACK（即丢失的那几个数据包）

如果再收到重复的 ACK，那么 cwnd = cwnd +1

如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。

# 17.TCP和UDP区别

①面向连接：TCP面向连接，UDP面向无连接

②可靠性：TCP可靠，UDP不可靠

③传输速度：TCP慢，UDP快

④报文格式：TCP面向字节流，UDP面向报文

⑤应用场景：TCP适用网页邮件等，UDP适用语音广播等

# 18.TCP为什么是可靠的

①连接和断开的可靠性：因为三次握手和四次挥手

②有状态：会记录哪些数据发了，哪些被接收了，哪些没被接收

③可控制：超时重传，流量控制，拥塞控制

# 19.TCP报文首部字段

![img](https://s1.ax1x.com/2022/05/10/ONrlmn.png)

**16位端口号**：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序

**32位序号**：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。

**32位确认号**：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。

**4位头部长度**：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。

**6位标志位**：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）

**16位窗口大小**：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。

**16位校验和**：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。

**16位紧急指针**：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。

# 20.为什么TCP是数据流，UDP是数据报

## ①数据流模式

是指**TCP发送端发送几次数据和接收端接收几次数据是没有必然联系的**，比如你通过 TCP连接给另一端发送数据，你只调用了一次 write，发送了100个字节，但是对方可以分10次收完，每次10个字节；你也可以调用10次write，每次10个字节，但是对方可以一次就收完。

**原因：**这是因为TCP是面向连接的，一个 socket 中收到的数据都是由同一台主机发出，且有序地到达，所以每次读取多少数据都可以。

## ②数据报模式

所谓的**“数据报模式”**，是指**UDP发送端调用了几次 write，接收端必须用相同次数的 read 读完**。UDP是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。

**原因：**这是因为UDP是无连接的，只要知道接收端的 IP 和端口，任何主机都可以向接收端发送数据。 这时候，如果一次能读取超过一个报文的数据， 则会乱套。

# 21.对称加密和非对称加密

## ①对称加密

双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。

## ②非对称加密

拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。
