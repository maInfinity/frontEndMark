# cookie

## 1.特性

①创建成功则名称无法修改

②无法跨域名共享

③大小**不超过4kb**，每个域名的cookie数量有限制（网上流传说20个，但是似乎并不是如此）

④有安全问题

⑤在请求一个新页面时，**cookie都会被发过去**

## 2.应用场景

最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。

**Tips：如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全**

# localStorage

## 1.特性

> 优点

①大小一般**5M左右**，比起cookie能存更多信息

②**持久存储**，除非手动清理

③**只存本地**，不会像cookie一样自动带在HTTP里

> 缺点

①受**同源策略**影响

②浏览器**兼容不好**，IE8及以下无法使用

## 2.API

```javascript
localStorage.setItem('key', value)
localStorage.getItem('key')
localStorage.removeItem('key')
localStorage.clear()	// 清空
localStorage.key(index) // 获取某个索引的key
```

## 3. 应用场景

①网站换肤



# sessionStorage

## 1.特性

与localStorage一样。

**除了：**

①关闭当前页面（关闭标签或关闭浏览器）会清空

②也受同源策略影响，但是比起localStorage更严格，只能在同一窗口下共享

## 2.应用场景

存一些游客的浏览信息和登录信息

# cookie登录和token登录

## 1.cookie验证

前端不需要做什么，只需要把用户名和密码传递给后端，后端接受到验证成功后，通过他们内置的方式，存入session中，会生成一个唯一的标识，并通过设置响应头，回传给前端。如下图所示。

<img src="https://s1.ax1x.com/2022/05/14/OcQ1gg.jpg" alt="img" style="zoom: 50%;" />

浏览器识别到有Set-Cookie字段，则会将内容存入到cookie中。然后以后的请求的都会携带着cookie传给后台接口。所以如果在跨域请求中，前端需要设置

```javas
axios.defaults.withCredentials = true  // 允许携带凭证
```

<img src="https://s1.ax1x.com/2022/05/14/OcQ7qA.jpg" alt="img" style="zoom:50%;" />

## 2.token验证

前端将用户名和密码传递给后端，后端接受到验证成功后，回传回来token。前端得到token，将token存入localStorage或者sessionStorage。然后再请求拦截器中或者axios默认配置中加上token。

```javascript
axios.defaults.headers.common['Authorization'] = token // token从localStorage或者sessionStorage取到
```

<img src="https://s1.ax1x.com/2022/05/14/OcQxxg.jpg" alt="img" style="zoom:50%;" />

# 强缓存

## 1.概念

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必请求服务器

## 2.设置方式

### ①Expires(http1.0)

通过在响应头中添加**Expires属性指定资源的过期时间**。在**时间内**，**资源可以被缓存使用，无需请求服务器**。

但是这个时间是服务器的绝对时间，当服务器的时间和客户端的时间不一致，会影响缓存命中的结果

### ②Cache-Control(http1.1)

**可设置字段：**

- max-age：**最大有效期**，单位是秒
- no-cache：先和服务器**确认资源是否更新**，如果**资源没变**化，则**直接使用缓存**资源
- no-store：**不使用缓存**，每次都会请求服务器

## 3.两种方式优先级

`Cache-Control`高于`Expires`

# 协商缓存

## 1.概念

如果**命中了强缓存**，则**直接使用缓存内容**，如果**没有命中强缓存**，且**设置了协商缓存**，则**协商缓存发挥作用**。

## 2.触发条件

①`max-age` 过期

②`no-cache`

使用协商缓存策略，会**先向服务器发一个请求**，若**资源没有修改**，则**返回304**，让**浏览器用本地缓存**。如果**资源发生改变则返回改变的资源**。

## 3.设置方式

### ①Last-Modified：

服务器返回时会在**响应头中放一个`Last-Modified`**，**值为资源的最后一次修改时间**。

下一次浏览器请求时会在**请求头中带上`If-Modified-Since`属性**，**值为上次返回资源时的`Last-Modified`的值**，然后**服务器**会进行**判断**，如果**这个值和资源的最后一次修改时间一样**，则**返回304**，浏览器取**本地缓存**，否则**返回修改后的资源**。

**存在的问题：**`Last-Modified`只能**精确到秒级**，即如果资源在1秒内修改了多次，文件变了，但是`Last-Modified`的值不会变，会导致缓存命中不准确

### ②Etag：

针对`Last-Modified`不准确的问题，使用`Etag`解决

服务器返回资源时，在**头信息中添加`Etag`属性**，`Etag`是资源生成的**唯一标识符**。当**资源发生改变**时，**`Etag`的值也会改变**。

当浏览器发送请求时会在**请求头中带上`If-None-Match`**，这个属性的**值是上次返回资源的`Etag`的值**。然后**服务器进行比对来判断资源是否发生变化**，并决定是否需要返回资源，这种方法更加准确。

## 4.两种方式优先级

`Last-Modified`和`Etag`同时出现时，`Etag`的优先级高。

# 强缓存和协商缓存总结

**共同：**两种缓存策略在**命中缓存时**都会直接使**用本地缓存**；在**不命中缓存时**都会向服务器**发请求来获取资源。**

**区别：**协商缓存会**向服务器发一次请求**，让服务器判断资源是否改变。

**关系：**合作关系。浏览器会**根据请求信息判断强缓存是否命中，命中则直接使用资源**；**未命中**则根据头信息向服务器发请求，**使用协商缓存**，如果**协商缓存命中了**，则**无返回**资源，直接**用本地缓存**，**未命中**才**获取返回资源**。

# 跨域解决方案

**注意：**这里是全部总结，实际开发只会用其中一两种，具体使用见**《*Vue实战随笔*》**

## 1.CORS

CORS需要浏览器和服务器的支持，但其实**关键是服务器，只要服务器实现了CORS请求，就可以跨域通信了。**

### ①简单请求

简单请求**不会触发CORS预检请求**，简单请求需要满足的条件：

1 >请求方法是以下几种：

- GET
- POST
- HEAD

2 >HTTP的头信息不超过以下几种：

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：只限三个值——application/x-www-form-urlencoded、multipart/form-data、text/plain

不满足以上条件即为非简单请求

> #### 简单请求的过程

对于简单请求，浏览器会直接发出CORS请求，并在**请求头中带一个Origin属性**，该**字段说明本次请求来自哪个源（协议 + 域名 + 端口号）**，服务器会根据这个值来决定是否同意此次请求。如果**Origin指定的域名在许可范围之内，则服务器返回的头信息中会多出如下字段**

```javascript
Access-Control-Allow-Origin: http://api.bob.com  	// 和Orign一直
Access-Control-Allow-Credentials: true   			// 表示是否允许发送Cookie
Access-Control-Expose-Headers: FooBar   			// 指定返回其他字段的值
Content-Type: text/html; charset=utf-8   			// 表示文档类型
```

如果Origin指定的域名**不在许可范围之内**，服务器会**返回一个正常的http响应**。此时浏览器没有发现上述代码中的`Access-Control-Allow-Origin`，就知道此次请求出错了，但是这个**错误无法通过状态码识别，因为返回的状态码有可能是200。**

> **注意：在简单请求中，服务期内，至少需要设置字段：`Access-Control-Allow-Origin`**

### ②非简单请求

非简单请求是指对服务器有特殊要求的请求，如PUT，DELETE等。**非简单请求的CORS请求会在正式通信之前**进行一次HTTP查询请求，称为**预检请求**

浏览器会询问服务器：当前所在的网页**是否在服务器允许的访问范围内**，以及**可以使用哪些HTTP请求方式**，以及**头信息字段**，只有**得到肯定回复，才会进行正式的HTTP请求**，否则报错。

> #### 预检请求的过程

预检请求的方法叫OPTIONS。他的头信息中的关键字段是：

`Origin`，表示请求**来自哪个源**

`Access-Control-Request-Method`，该字段必须，列出浏览器的**CORS请求会用到的方法**

`Access-Control-Request-Headers`，该字段是一个逗号分隔字符串，指定浏览器CORS请求会**额外携带的头信息字段**

服务器收到浏览器的预检请求后，会根据头信息中的3个字段判断，如果**返回的头信息中有`Access-Control-Allow-Origin`代表允许跨域请求，否则就是不同意这个预检请求**，报错

```javascript
Access-Control-Allow-Origin: http://api.bob.com // 允许跨域的源地址
Access-Control-Allow-Methods: GET, POST, PUT 	// 服务器支持的所有跨域请求的方法
Access-Control-Allow-Headers: X-Custom-Header  	// 服务器支持的所有头信息字段
Access-Control-Allow-Credentials: true   		// 表示是否允许发送Cookie
Access-Control-Max-Age: 1728000  				// 用来指定本次预检请求的有效期，单位为秒
```

> **注意1：**只要服务器**通过了预检请求**，在**以后每次的CORS请求都会自带一个Origin头信息字段**。服务器的**回应，也都会有一个Access-Control-Allow-Origin**头信息字段。

> **注意2：在非简单请求中，至少需要设置以下字段：**
>
> ```javascript
> 'Access-Control-Allow-Origin'  
> 'Access-Control-Allow-Methods'
> 'Access-Control-Allow-Headers'
> ```

> #### 减少Options请求次数

OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。

> #### CORS中Cookie问题

- ```javascript
  // 原生 xml 的设置方式
  var xhr = new XMLHttpRequest();
  xhr.withCredentials = true;
  // axios 设置方式
  axios.defaults.withCredentials = true;
  ```

- **Access-Control-Allow-Credentials 设置为 true**

- **Access-Control-Allow-Origin 设置为非** *

## 2.JSONP

### ①原理

利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的**GET请求**，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。

### ②实现

**1>原生js实现**

```javascript
<script>
    var script = document.createElement('script');
script.type = 'text/javascript';
// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
document.head.appendChild(script);
// 回调执行函数
function handleCallback(res) {
    alert(JSON.stringify(res));
}
</script>
```

服务端返回如下

```javascript
handleCallback({"success": true, "user": "admin"})
```

**2>Vue axios实现**

```javascript
this.$http = axios;
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

### ③缺点

**1>只支持GET**

**2>不安全，可能遭受XSS攻击**

## 3.postMessage

postMessage(data,origin)方法接受两个参数：

- **data**： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
- **origin**： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

```javascript
iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
```

## 4.nginx代理跨域

## 5.nodejs中间件代理跨域

修改webpack.config.js配置

```javascript
devServer: {
    proxy: [{
        context: '/login',
        target: 'http://www.domain2.com:8080',  // 代理跨域目标接口
        changeOrigin: true,
        secure: false,  // 当代理某些https服务报错时用
        cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
    }],

}
```

## 6.document.domain + iframe

仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都**通过js强制设置document.domain为基础主域**，就实现了同域。

1>父窗口

```javascript
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
	var user = 'admin';
</script>
```

2>子窗口

```javascript
<script>
    document.domain = 'domain.com';
	// 获取父窗口中变量
	console.log('get js data from parent ---> ' + window.parent.user);
</script>
```

## 7.WebSocket

