# cookie

## 1.特性

①创建成功则名称无法修改

②无法跨域名共享

③大小**不超过4kb**，每个域名的cookie数量有限制（网上流传说20个，但是似乎并不是如此）

④有安全问题

⑤在请求一个新页面时，**cookie都会被发过去**

## 2.应用场景

最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。

**Tips：如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全**

# localStorage

## 1.特性

> 优点

①大小一般**5M左右**，比起cookie能存更多信息

②**持久存储**，除非手动清理

③**只存本地**，不会像cookie一样自动带在HTTP里

> 缺点

①受**同源策略**影响

②浏览器**兼容不好**，IE8及以下无法使用

## 2.API

```javascript
localStorage.setItem('key', value)
localStorage.getItem('key')
localStorage.removeItem('key')
localStorage.clear()	// 清空
localStorage.key(index) // 获取某个索引的key
```

## 3. 应用场景

①网站换肤



# sessionStorage

## 1.特性

与localStorage一样。

**除了：**

①关闭当前页面（关闭标签或关闭浏览器）会清空

②也受同源策略影响，但是比起localStorage更严格，只能在同一窗口下共享

## 2.应用场景

存一些游客的浏览信息和登录信息

# cookie登录和token登录

## 1.cookie验证

前端不需要做什么，只需要把用户名和密码传递给后端，后端接受到验证成功后，通过他们内置的方式，存入session中，会生成一个唯一的标识，并通过设置响应头，回传给前端。如下图所示。

<img src="https://s1.ax1x.com/2022/05/14/OcQ1gg.jpg" alt="img" style="zoom: 50%;" />

浏览器识别到有Set-Cookie字段，则会将内容存入到cookie中。然后以后的请求的都会携带着cookie传给后台接口。所以如果在跨域请求中，前端需要设置

```javas
axios.defaults.withCredentials = true  // 允许携带凭证
```

<img src="https://s1.ax1x.com/2022/05/14/OcQ7qA.jpg" alt="img" style="zoom:50%;" />

## 2.token验证

前端将用户名和密码传递给后端，后端接受到验证成功后，回传回来token。前端得到token，将token存入localStorage或者sessionStorage。然后再请求拦截器中或者axios默认配置中加上token。

```javascript
axios.defaults.headers.common['Authorization'] = token // token从localStorage或者sessionStorage取到
```

<img src="https://s1.ax1x.com/2022/05/14/OcQxxg.jpg" alt="img" style="zoom:50%;" />

# 强缓存

## 1.概念

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必请求服务器

## 2.设置方式

### ①Expires(http1.0)

通过在响应头中添加**Expires属性指定资源的过期时间**。在**时间内**，**资源可以被缓存使用，无需请求服务器**。

但是这个时间是服务器的绝对时间，当服务器的时间和客户端的时间不一致，会影响缓存命中的结果

### ②Cache-Control(http1.1)

**可设置字段：**

- max-age：**最大有效期**，单位是秒
- no-cache：先和服务器**确认资源是否更新**，如果**资源没变**化，则**直接使用缓存**资源
- no-store：**不使用缓存**，每次都会请求服务器

## 3.两种方式优先级

`Cache-Control`高于`Expires`

# 协商缓存

## 1.概念

如果**命中了强缓存**，则**直接使用缓存内容**，如果**没有命中强缓存**，且**设置了协商缓存**，则**协商缓存发挥作用**。

## 2.触发条件

①`max-age` 过期

②`no-cache`

使用协商缓存策略，会**先向服务器发一个请求**，若**资源没有修改**，则**返回304**，让**浏览器用本地缓存**。如果**资源发生改变则返回改变的资源**。

## 3.设置方式

### ①Last-Modified：

服务器返回时会在**响应头中放一个`Last-Modified`**，**值为资源的最后一次修改时间**。

下一次浏览器请求时会在**请求头中带上`If-Modified-Since`属性**，**值为上次返回资源时的`Last-Modified`的值**，然后**服务器**会进行**判断**，如果**这个值和资源的最后一次修改时间一样**，则**返回304**，浏览器取**本地缓存**，否则**返回修改后的资源**。

**存在的问题：**`Last-Modified`只能**精确到秒级**，即如果资源在1秒内修改了多次，文件变了，但是`Last-Modified`的值不会变，会导致缓存命中不准确

### ②Etag：

针对`Last-Modified`不准确的问题，使用`Etag`解决

服务器返回资源时，在**头信息中添加`Etag`属性**，`Etag`是资源生成的**唯一标识符**。当**资源发生改变**时，**`Etag`的值也会改变**。

当浏览器发送请求时会在**请求头中带上`If-None-Match`**，这个属性的**值是上次返回资源的`Etag`的值**。然后**服务器进行比对来判断资源是否发生变化**，并决定是否需要返回资源，这种方法更加准确。

## 4.两种方式优先级

`Last-Modified`和`Etag`同时出现时，`Etag`的优先级高。

# 强缓存和协商缓存总结

**共同：**两种缓存策略在**命中缓存时**都会直接使**用本地缓存**；在**不命中缓存时**都会向服务器**发请求来获取资源。**

**区别：**协商缓存会**向服务器发一次请求**，让服务器判断资源是否改变。

**关系：**合作关系。浏览器会**根据请求信息判断强缓存是否命中，命中则直接使用资源**；**未命中**则根据头信息向服务器发请求，**使用协商缓存**，如果**协商缓存命中了**，则**无返回**资源，直接**用本地缓存**，**未命中**才**获取返回资源**。

